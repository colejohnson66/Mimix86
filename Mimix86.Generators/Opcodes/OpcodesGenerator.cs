/* =============================================================================
 * File:   OpcodesGenerator.cs
 * Author: Cole Tobin
 * =============================================================================
 * Purpose:
 *
 * Generates the following:
 *   - `Opcode.List.g.cs` - all opcodes known to Mimix86
 *   - `OpcodeMap.cs`     - the map of bytes into opcodes (TODO)
 * =============================================================================
 * Copyright (c) 2022-2023 Cole Tobin
 *
 * This file is part of Mimix86.
 *
 * Mimix86 is free software: you can redistribute it and/or modify it under the
 *   terms of the GNU General Public License as published by the Free Software
 *   Foundation, either version 3 of the License, or (at your option) any later
 *   version.
 *
 * Mimix86 is distributed in the hope that it will be useful, but WITHOUT ANY
 *   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *   FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 *   details.
 *
 * You should have received a copy of the GNU General Public License along with
 *   Mimix86. If not, see <http://www.gnu.org/licenses/>.
 * =============================================================================
 */

using DslLib;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Mimix86.Generators.Opcodes;

public static class OpcodesGenerator
{
    private const string OPCODE_LIST_TEMPLATE_HEADER =
        $$"""
        // generated by `{{nameof(Mimix86)}}.{{nameof(Generators)}}.{{nameof(Opcodes)}}.{{nameof(OpcodesGenerator)}}`
        // any changes will be lost on next generation

        using Mimix86.Core.Cpu.Execution;
        using System;

        namespace Mimix86.Core.Cpu.Decoder;

        public sealed partial class Opcode
        {
            /// <summary>
            /// The "undefined" opcode.
            /// Used to signify that the instruction stream decodes to an undefined opcode.
            /// </summary>
            public static Opcode Undefined { get; } = new("<error>", Execution.Error._, 0, 0);

        """;

    private const string OPCODE_MAP_TEMPLATE_HEADER =
        $$"""
        // generated by `{{nameof(Mimix86)}}.{{nameof(Generators)}}.{{nameof(Opcodes)}}.{{nameof(OpcodesGenerator)}}`
        // any changes will be lost on next generation

        using System;
        using static Mimix86.Core.Cpu.Decoder.DecodeFlags;
        using static Mimix86.Core.Cpu.Decoder.Opcode;

        namespace Mimix86.Core.Cpu.Decoder;

        // CS1591 is XML documentation
        #pragma warning disable CS1591

        /// <summary>
        /// Enumerates all the supported opcodes by their location in the various opmaps.
        /// </summary>
        [SuppressMessage("ReSharper", "InconsistentNaming")]
        public static class OpcodeMap
        {
            public static readonly OpcodeMapEntry[] OpcodeUndefined =
            {
                new(Undefined, .., DecodeFlags.None),
            };

        """;

    /* ADD [Eb Gb] [00 /r] .. [lock]
     *      |
     *      v
     * public static Opcode AddEbGb { get; } = new("add", Add.EbGb, OpcodeFlags.Lockable, 0);
     */

    private static readonly List<Opcode> KnownOpcodes = new();
    private static readonly SortedDictionary<uint, List<Opcode>> OutputMap = new();

    public static void Run()
    {
        foreach (string path in Directory.GetFiles("./Data/Opcodes", "*.m86"))
            ReadInput(path);

        WriteOpcodeList();

        BuildOutputMap();
        WriteOutputMap();
    }

    private static void ReadInput(string path)
    {
        string contents = File.ReadAllText(path);
        using Parser parser = new(contents);

        foreach (Node node in parser.Parse())
            KnownOpcodes.Add(new(node));
    }

    private static void WriteOpcodeList()
    {
        string outputPath = Path.Combine(Helpers.Mimix86CorePath, "Cpu", "Decoder", "Opcode.StaticFields.g.cs");
        using FileStream handle = File.Open(outputPath, FileMode.Create, FileAccess.Write);
        using StreamWriter writer = new(handle);

        writer.Write(OPCODE_LIST_TEMPLATE_HEADER);
        foreach (Opcode op in KnownOpcodes.Distinct().Order())
        {
            writer.WriteLine();
            writer.WriteLine(op.GenerateOpcodeMember());
        }
        writer.WriteLine("}");
    }

    private static void BuildOutputMap()
    {
        for (uint i = 0; i <= 0xFF; i++)
            OutputMap.Add(i, new());

        foreach (Opcode op in KnownOpcodes.Distinct())
            OutputMap[op.Encoding.Opcode].Add(op);
    }

    private static void WriteOutputMap()
    {
        string outputPath = Path.Combine(Helpers.Mimix86CorePath, "Cpu", "Decoder", "OpcodeMap.g.cs");
        using FileStream handle = File.Open(outputPath, FileMode.Create, FileAccess.Write);
        using StreamWriter writer = new(handle);

        writer.Write(OPCODE_MAP_TEMPLATE_HEADER);
        foreach ((uint opByte, List<Opcode> list) in OutputMap)
        {
            // early bail for prefixes
            if (opByte is 0x26 or 0x2E or 0x36 or 0x3E or 0xF0 or 0xF2 or 0xF3)
                continue;

            string definition = $"    public static readonly OpcodeMapEntry[] Opcode{opByte:X2} =";

            writer.WriteLine();
            if (!list.Any())
            {
                writer.WriteLine($"{definition} Array.Empty<OpcodeMapEntry>();");
                continue;
            }

            writer.WriteLine(definition);
            writer.WriteLine("    {");
            foreach (Opcode op in list.Order())
                // TODO: include decode flags
                writer.WriteLine($"        new({op.TitleCaseMnemonic}{op.OperandsString}, {op.RequiredCpu}),");
            writer.WriteLine("    };");
        }
    }
}
