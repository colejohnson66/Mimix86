/* =============================================================================
 * File:   OpcodesGenerator.cs
 * Author: Cole Tobin
 * =============================================================================
 * Purpose:
 *
 * Generates the following:
 *   - `Opcode.List.g.cs` - all opcodes known to Mimix86
 *   - `OpcodeMap.cs`     - the map of bytes into opcodes (TODO)
 * =============================================================================
 * Copyright (c) 2022-2023 Cole Tobin
 *
 * This file is part of Mimix86.
 *
 * Mimix86 is free software: you can redistribute it and/or modify it under the
 *   terms of the GNU General Public License as published by the Free Software
 *   Foundation, either version 3 of the License, or (at your option) any later
 *   version.
 *
 * Mimix86 is distributed in the hope that it will be useful, but WITHOUT ANY
 *   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *   FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 *   details.
 *
 * You should have received a copy of the GNU General Public License along with
 *   Mimix86. If not, see <http://www.gnu.org/licenses/>.
 * =============================================================================
 */

using DslLib;
using Mimix86.Generators.Opcodes.Encoding;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Mimix86.Generators.Opcodes;

public static class OpcodesGenerator
{
    private const string OPCODE_LIST_TEMPLATE_HEADER =
        $$"""
        // generated by `{{nameof(Mimix86)}}.{{nameof(Generators)}}.{{nameof(Opcodes)}}.{{nameof(OpcodesGenerator)}}`
        // any changes will be lost on next generation

        using Mimix86.Core.Cpu.Execution;
        using System;

        namespace Mimix86.Core.Cpu.Decoder;

        public sealed partial class Opcode
        {
            /// <summary>
            /// The "undefined" opcode.
            /// Used to signify that the instruction stream decodes to an undefined opcode.
            /// </summary>
            public static Opcode Undefined { get; } = new("<error>", Execution.Error._, 0, 0);

        """;

    private const string OPCODE_MAP_TEMPLATE_HEADER =
        $$"""
        // generated by `{{nameof(Mimix86)}}.{{nameof(Generators)}}.{{nameof(Opcodes)}}.{{nameof(OpcodesGenerator)}}`
        // any changes will be lost on next generation

        using static Mimix86.Core.Cpu.Decoder.DecodeFlags;
        using static Mimix86.Core.Cpu.Decoder.Opcode;

        namespace Mimix86.Core.Cpu.Decoder;

        // CS1591 is XML doc comments
        #pragma warning disable CS1591
        // ReSharper disable InconsistentNaming

        /// <summary>
        /// Enumerates all the supported opcodes by their location in the various opmaps.
        /// </summary>
        public static class OpcodeMap
        {
            public static readonly OpcodeMapEntry[] OpcodeUndefined =
            {
                new(Undefined, .., DecodeFlags.None),
            };

        """;

    /* ADD [Eb Gb] [00 /r] .. [lock]
     *      |
     *      v
     * public static Opcode AddEbGb { get; } = new("add", Add.EbGb, OpcodeFlags.Lockable, 0);
     */

    private static readonly List<Opcode> KnownOpcodes = new();
    private static readonly SortedDictionary<string, List<Opcode>> OpcodeMap = new();

    public static void Run()
    {
        foreach (string path in Directory.GetFiles("./Data/Opcodes", "*.m86"))
            ReadInput(path);

        WriteOpcodeList();

        BuildOpcodeMap();
        WriteOpcodeMap();
    }

    private static void ReadInput(string path)
    {
        string contents = File.ReadAllText(path);
        using Parser parser = new(contents);

        foreach (Node node in parser.Parse())
            KnownOpcodes.Add(new(node));
    }

    private static void WriteOpcodeList()
    {
        string outputPath = Path.Combine(Helpers.Mimix86CorePath, "Cpu", "Decoder", "Opcode.StaticFields.g.cs");
        using FileStream handle = File.Open(outputPath, FileMode.Create, FileAccess.Write);
        using StreamWriter writer = new(handle);

        writer.Write(OPCODE_LIST_TEMPLATE_HEADER);
        foreach (Opcode op in KnownOpcodes.DistinctBy(op => (op.TitleCaseMnemonic, op.OperandsString)).Order())
        {
            writer.WriteLine();
            writer.WriteLine(op.GenerateOpcodeMember());
        }
        writer.WriteLine("}");
    }

    private static void BuildOpcodeMap()
    {
        // when building the opcode map, we also need to consider the encoding, unlike the opcode list
        foreach (Opcode op in KnownOpcodes.DistinctBy(op => (op.TitleCaseMnemonic, op.OperandsString, op.Encoding)))
        {
            // "get or insert" operation here
            string key = op.Encoding.OpcodeMapEntryName;
            if (!OpcodeMap.TryGetValue(key, out List<Opcode>? value))
            {
                value = new();
                OpcodeMap.Add(key, value);
            }

            value.Add(op);
        }
    }

    private static void WriteOpcodeMap()
    {
        string outputPath = Path.Combine(Helpers.Mimix86CorePath, "Cpu", "Decoder", "OpcodeMap.g.cs");
        using FileStream handle = File.Open(outputPath, FileMode.Create, FileAccess.Write);
        using StreamWriter writer = new(handle);

        writer.Write(OPCODE_MAP_TEMPLATE_HEADER);
        foreach ((string entryName, List<Opcode> entryList) in OpcodeMap)
        {
            string definition = $"    public static readonly OpcodeMapEntry[] Opcode{entryName} =";
            writer.WriteLine();

            // if (!list.Any())
            // {
            //     // empty blocks
            //     writer.WriteLine($"{definition} Array.Empty<OpcodeMapEntry>();");
            //     continue;
            // }

            writer.WriteLine(definition);
            writer.WriteLine("    {");
            foreach (Opcode op in entryList.Order())
            {
                writer.Write($"        new({op.TitleCaseMnemonic}{op.OperandsString}, {op.RequiredCpuLevelString}");
                EncodingPart.ModRM? modRM = op.Encoding.ModRM;
                if (modRM?.HasAnyRequiredFields is true) // ModR/M decode flags only matter if any are required
                    writer.Write($", {modRM.BuildDecodeFlagsString()}");
                writer.WriteLine("),");
            }
            writer.WriteLine("    };");
        }
        writer.WriteLine("}");
    }
}
