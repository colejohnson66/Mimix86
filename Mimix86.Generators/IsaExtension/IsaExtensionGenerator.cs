/* =============================================================================
 * File:   IsaExtensionGenerator.cs
 * Author: Cole Tobin
 * =============================================================================
 * Copyright (c) 2023 Cole Tobin
 *
 * This file is part of Mimix86.
 *
 * Mimix86 is free software: you can redistribute it and/or modify it under the
 *   terms of the GNU General Public License as published by the Free Software
 *   Foundation, either version 3 of the License, or (at your option) any later
 *   version.
 *
 * Mimix86 is distributed in the hope that it will be useful, but WITHOUT ANY
 *   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *   FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 *   details.
 *
 * You should have received a copy of the GNU General Public License along with
 *   Mimix86. If not, see <http://www.gnu.org/licenses/>.
 * =============================================================================
 */

using SExpressionReader;
using System.IO;
using System.Linq;

namespace Mimix86.Generators.IsaExtension;

public static class IsaExtensionGenerator
{
    private const string FILE_TEMPLATE_HEADER =
        $$"""
        // generated by `{{nameof(Mimix86)}}.{{nameof(Generators)}}.{{nameof(IsaExtension)}}.{{nameof(IsaExtensionGenerator)}}`
        // any changes will be lost on next generation

        namespace Mimix86.Core.Cpu;

        public readonly partial struct IsaExtension
        {
        """;

    /* (physical-address-extensions "Physical Address Extensions (PAE).")
     *      |
     *      v
     * /// <summary>Physical Address Extensions (PAE).</summary>
     * public static IsaExtension PhysicalAddressExtensions { get; } = new(x);
     */

    public static void Run()
    {
        string contents = File.ReadAllText("./Data/IsaExtension/list.lisp");
        using Parser parser = new(contents);

        string outputPath = Path.Combine(Helpers.Mimix86CorePath, "Cpu", "IsaExtension.StaticFields.g.cs");
        using FileStream handle = File.Open(outputPath, FileMode.Create, FileAccess.Write);
        using StreamWriter writer = new(handle);

        int currentIndex = 0;
        writer.Write(FILE_TEMPLATE_HEADER);
        foreach (Expression expr in parser.Parse())
        {
            AtomOrExpression[] children = expr.ToArray();
            if (children.Length is 0)
                throw new InvalidDataException("Empty outer expression encountered.");
            if (!children[0].TryAsAtom(out Atom exprName) || exprName.As<string>() is not "extensions")
                throw new InvalidDataException("Unknown outermost expression.");

            foreach (AtomOrExpression aoe in children.Skip(1))
            {
                if (!aoe.TryAsExpression(out Expression? extension))
                    throw new InvalidDataException("Unknown atom inside extensions list.");
                ProcessExtension(ref currentIndex, writer, extension);
            }
        }

        writer.WriteLine("}");
    }

    private static void ProcessExtension(ref int bitIndex, StreamWriter writer, Expression expr)
    {
        if (expr.Count is not 2)
            throw new InvalidDataException($"Expected an expression of length 2, but found one of length {expr.Count}.");

        if (!expr[0].TryAsAtom(out Atom name) || !expr[1].TryAsAtom(out Atom description))
            throw new InvalidDataException($"One or both extension expression children are not atoms.");

        writer.WriteLine();
        writer.WriteLine($"    /// <summary>{description.As<string>()}</summary>");
        writer.WriteLine($"    public static IsaExtension {Helpers.KebabCaseToPascalCase(name.As<string>())} {{ get; }} = new({bitIndex});");
    }
}
